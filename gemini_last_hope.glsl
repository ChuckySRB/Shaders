// --- "Axiom Data Core" ---
//
// Description:
// A dynamic, cellular automata-inspired shader. It simulates a grid of "data axioms"
// or "digital cells." Each cell's appearance (its "core" and "membrane") is
// generated by a unique, stable hash (its "DNA").
//
// Mouse Interaction:
// The mouse acts as a "catalyst" or "energy probe."
// - It brightens the cells it hovers over.
// - It dramatically accelerates the internal "processing" (animation) of nearby cells.
//
// This is not a flow field. It's a living, thinking substrate.

// --- High-quality hashing functions ---
// Provides the "DNA" for each cell
vec2 hash2(vec2 p) {
    // A more robust hash (based on pcg_2d)
    p = vec2(dot(p, vec2(127.1, 311.7)), dot(p, vec2(269.5, 183.3)));
    return -1.0 + 2.0 * fract(sin(p) * 43758.5453123);
}

float hash(vec2 p) {
    return fract(sin(dot(p, vec2(12.9898, 78.233))) * 43758.5453);
}

// --- Modern Color Palette Function ---
vec3 palette(float t, vec3 a, vec3 b, vec3 c, vec3 d) {
    return a + b * cos(6.28318 * (c * t + d));
}

void mainImage(out vec4 fragColor, in vec2 fragCoord) {
    // --- Setup ---
    vec2 uv = (fragCoord - 0.5 * iResolution.xy) / iResolution.y;
    vec2 mouse = (iMouse.xy - 0.5 * iResolution.xy) / iResolution.y;
    
    // Use mouse only if clicked/dragged
    if (iMouse.z <= 0.0) {
        // If mouse is not active, park it off-screen
        // or let it drift for a passive animation
        mouse = vec2(cos(iTime * 0.1) * 0.8, sin(iTime * 0.15) * 0.5);
    }
    
    // --- Dynamic Cellular Grid (Voronoi) ---
    // This creates the "cells." Instead of static points,
    // the cell centers "vibrate," making the whole grid feel alive.
    
    vec2 grid_uv = uv * 6.0; // Scale of the grid
    vec2 cell_id = floor(grid_uv);
    vec2 cell_frac = fract(grid_uv);
    
    float min_dist_to_core = 1e6; // Min distance to a cell's "nucleus"
    float min_dist_to_edge = 1e6; // Min distance to a cell's "membrane"
    vec2 core_pos = vec2(0.0);
    vec2 cell_dna = vec2(0.0); // The unique "gene" of the cell we are in

    // Search 3x3 neighbor grid to find the closest cell center
    for (float y = -1.0; y <= 1.0; y++) {
        for (float x = -1.0; x <= 1.0; x++) {
            vec2 neighbor_id = vec2(x, y);
            vec2 current_id = cell_id + neighbor_id;
            
            // Get the unique "DNA" (a random-looking vector) for this cell
            vec2 cell_hash = hash2(current_id);
            
            // The "core" position vibrates based on its DNA and time
            vec2 core_vibration = 0.4 * sin(iTime * 1.5 * cell_hash + cell_hash.yx * 3.14);
            vec2 p = neighbor_id + 0.5 + core_vibration;
            
            float dist = length(cell_frac - p);
            
            // This is a trick to get the "cell wall" (border)
            // We track the *second* closest core, not just the first.
            if (dist < min_dist_to_core) {
                min_dist_to_edge = min_dist_to_core; // Store old min as second min
                min_dist_to_core = dist;             // Store new min
                core_pos = p;
                cell_dna = cell_hash; // Store the "DNA" of this cell
            } else if (dist < min_dist_to_edge) {
                min_dist_to_edge = dist;
            }
        }
    }
    
    // --- Mouse Interaction ---
    // Calculate distance from this pixel to the mouse
    float mouse_dist = length(uv - mouse);
    // Create a "catalyst" field: 1.0 near mouse, 0.0 far away
    float catalyst = smoothstep(0.2, 0.0, mouse_dist); // 0.2 radius of influence
    
    // --- Rendering ---
    
    // 1. Render the "Core" (The Nucleus)
    // The core's brightness is based on its distance from the center
    float core = smoothstep(0.1, 0.0, min_dist_to_core);
    // The core gets brighter when activated by the mouse
    core *= (1.0 + catalyst * 3.0); 
    
    // 2. Render the "Internal Data" (The AI/DNA part)
    // This is the "processing" inside the cell
    float cell_time = iTime * (1.0 + cell_dna.x * 0.5); // Each cell has its own speed
    // Mouse dramatically accelerates local processing
    cell_time += catalyst * iTime * 2.0; 
    
    // A complex, swirling pattern inside the core
    float internal_data = sin(min_dist_to_core * 20.0 - cell_time * 3.0);
    internal_data *= cos(atan(cell_frac.y - core_pos.y, cell_frac.x - core_pos.x) * (3.0 + floor(cell_dna.y * 5.0)));
    internal_data = smoothstep(0.0, 1.0, internal_data);
    
    // Only show internal data *inside* the core's radius
    internal_data *= smoothstep(0.2, 0.15, min_dist_to_core);
    
    // 3. Render the "Membrane" (The Cell Wall)
    // The wall is the boundary between the two closest cells
    float membrane = smoothstep(0.0, 0.05, min_dist_to_edge - min_dist_to_core);
    // Membranes glow brightly when catalyzed
    membrane *= (1.0 + catalyst * 2.0);

    // --- Coloring ---
    
    // Base color for the cell, derived from its "DNA"
    float cell_hue = cell_dna.x * 0.5 + 0.5; // Use DNA to pick a hue
    vec3 base_color = palette(cell_hue, 
                              vec3(0.5, 0.5, 0.5), 
                              vec3(0.5, 0.5, 0.5), 
                              vec3(1.0, 1.0, 1.0), 
                              vec3(0.0, 0.33, 0.67));
    
    // Final color assembly
    vec3 color = vec3(0.0);
    
    // Additive blending for a "glowing" look
    color += base_color * core * 0.5; // The core's glow
    color += vec3(1.0) * internal_data * base_color; // The bright "data"
    color += vec3(0.8, 1.0, 1.0) * membrane; // The electric-cyan membranes
    
    // 4. Post-Processing: Background Atmosphere
    // Add a subtle, distant nebulae / scientific-visualization feel
    float fbm = 0.0;
    vec2 uv_fbm = uv * 1.5;
    float a = 0.5;
    for(int i = 0; i < 3; i++) {
        fbm += a * hash(uv_fbm);
        uv_fbm *= 2.0;
        a *= 0.5;
    }
    color += fbm * 0.05; // Very subtle background texture
    
    // Final output
    fragColor = vec4(color, 1.0);
}